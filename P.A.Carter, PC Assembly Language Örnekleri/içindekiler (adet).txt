ÝÇÝNDEKÝLER (adet)
==========================
P.A.Carter, PC Assembly Language

1 Introduction
1.1 Number Systems
1.1.1 Decimal
1.1.2 Binary
1.1.3 Hexadecimal
1.2 Computer Organization
1.2.1 Memory
1.2.2 The CPU
1.2.3 The 80x86 family of CPUs
1.2.4 8086 16-bit Registers
1.2.5 80386 32-bit registers
1.2.6 Real Mode
1.2.7 16-bit Protected Mode
1.2.8 32-bit Protected Mode
1.2.9 Interrupts
1.3 Assembly Language
1.3.1 Machine language
1.3.2 Assembly language
1.3.3 Instruction operands
1.3.4 Basic instructions
1.3.5 Directives
1.3.6 Input and Output
1.3.7 Debugging
1.4 Creating a Program
1.4.1 First program
1.4.2 Compiler dependencies
1.4.3 Assembling the code
1.4.4 Compiling the C code
1.4.5 Linking the object files
1.4.6 Understanding an assembly listing file
1.5 Skeleton File

2 Basic Assembly Language
2.1 Working with Integers
2.1.1 Integer representation
2.1.2 Sign extension
2.1.3 Two’s complement arithmetic
2.1.4 Example program
2.1.5 Extended precision arithmetic
2.2 Control Structures
2.2.1 Comparisons
2.2.2 Branch instructions
2.2.3 The loop instructions
2.3 Translating Standard Control Structures
2.3.1 If statements
2.3.2 While loops
2.3.3 Do while loops
2.4 Example: Finding Prime Numbers

3 Bit Operations
3.1 Shift Operations
3.1.1 Logical shifts
3.1.2 Use of shifts
3.1.3 Arithmetic shifts
3.1.4 Rotate shifts
3.1.5 Simple application
3.2 Boolean Bitwise Operations
3.2.1 The AND operation
3.2.2 The OR operation
3.2.3 The XOR operation
3.2.4 The NOT operation
3.2.5 The TEST instruction
3.2.6 Uses of bit operations
3.3 Avoiding Conditional Branches
3.4 Manipulating bits in C
3.4.1 The bitwise operators of C
3.4.2 Using bitwise operators in C
3.5 Big and Little Endian Representations
3.5.1 When to Care About Little and Big Endian
3.6 Counting Bits
3.6.1 Method one
3.6.2 Method two
3.6.3 Method three

4 Subprograms
4.1 Indirect Addressing
4.2 Simple Subprogram Example
4.3 The Stack
4.4 The CALL and RET Instructions
4.5 Calling Conventions
4.5.1 Passing parameters on the stack
4.5.2 Local variables on the stack
4.6 Multi-Module Programs
4.7 Interfacing Assembly with C
4.7.1 Saving registers
4.7.2 Labels of functions
4.7.3 Passing parameters
4.7.4 Calculating addresses of local variables
4.7.5 Returning values
4.7.6 Other calling conventions
4.7.7 Examples
4.7.8 Calling C functions from assembly
4.8 Reentrant and Recursive Subprograms
4.8.1 Recursive subprograms
4.8.2 Review of C variable storage types

5 Arrays
5.1 Introduction
5.1.1 Defining arrays
5.1.2 Accessing elements of arrays
5.1.3 More advanced indirect addressing
5.1.4 Example
5.1.5 Multidimensional Arrays
5.2 Array/String Instructions
5.2.1 Reading and writing memory
5.2.2 The REP instruction prefix
5.2.3 Comparison string instructions
5.2.4 The REPx instruction prefixes
5.2.5 Example

6 Floating Point
6.1 Floating Point Representation
6.1.1 Non-integral binary numbers
6.1.2 IEEE floating point representation
6.2 Floating Point Arithmetic
6.2.1 Addition
6.2.2 Subtraction
6.2.3 Multiplication and division
6.2.4 Ramifications for programming
6.3 The Numeric Coprocessor
6.3.1 Hardware
6.3.2 Instructions
6.3.3 Examples
6.3.4 Quadratic formula
6.3.5 Reading array from file
6.3.6 Finding primes

7 Structures and C++
7.1 Structures
7.1.1 Introduction
7.1.2 Memory alignment
7.1.3 Bit Fields
7.1.4 Using structures in assembly
7.2 Assembly and C++
7.2.1 Overloading and Name Mangling
7.2.2 References
7.2.3 Inline functions
7.2.4 Classes
7.2.5 Inheritance and Polymorphism
7.2.6 Other C++ features

A 80x86 Instructions
A.1 Non-floating Point Instructions
A.2 Floating Point Instructions